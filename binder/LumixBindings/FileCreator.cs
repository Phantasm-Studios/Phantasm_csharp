using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;

namespace LumixBindings
{
    public class FileCreator
    {
        StreamWriter writer_;
        List<Class> writtenClasses = new List<Class>();
        List<string> headers_;

        public FileCreator(List<string> headers)
        {
            headers_ = headers;
        }
        public void Start()
        {
            writer_= new StreamWriter("out.cxx");
            writer_.WriteLine("/* ----------------------------------------------------------------------------");
            writer_.WriteLine("* This file was automatically generated by LumixBindings.");
            writer_.WriteLine("* Version " + Bindings.Version);
            writer_.WriteLine(" * ----------------------------------------------------------------------------- */");
            writer_.WriteLine("#pragma once");
            writer_.WriteLine("");
            writer_.WriteLine("");
            writer_.WriteLine("#ifndef ATOMIC_BINDING");
            writer_.WriteLine("#define ATOMIC_BINDING");
            writer_.WriteLine("#endif");
            writer_.WriteLine("");
            writer_.WriteLine("#ifndef ATOMIC_BINDING_EXPORT");
            writer_.WriteLine("#define ATOMIC_BINDING_EXPORT __declspec(dllexport)");
            writer_.WriteLine("#endif");
            writer_.WriteLine("");
            writer_.WriteLine("#ifndef ATOMIC_BINDING_STDCALL");
            writer_.WriteLine("#define ATOMIC_BINDING_STDCALL __stdcall");
            writer_.WriteLine("#endif");
            writer_.WriteLine("");
            writer_.WriteLine("");

            foreach (var header in headers_)
                writer_.WriteLine("#include \"" + header.Replace(Bindings.RootPath,"") + "\"");

            writer_.WriteLine("using namespace Atomic;");
            writer_.WriteLine("");
            writer_.WriteLine("");
            writer_.WriteLine("#ifdef __cplusplus");
            writer_.WriteLine("extern \"C\" {");
            writer_.WriteLine("#endif");
            writer_.WriteLine("");

        }

         
        public void Finish()
        {
            if (File.Exists("cExtensions.cpp"))
            {
                writer_.WriteLine(File.ReadAllText("cExtensions.cpp"));
            }
            writer_.WriteLine("");
            writer_.WriteLine("");
            writer_.WriteLine("#ifdef __cplusplus");
            writer_.WriteLine("}//end extern c");
            writer_.WriteLine("#endif");
            writer_.Flush();
            writer_.Close();
            writer_.Dispose();

        }

        public void StartCSharp()
        {
            writtenClasses.Clear();
            writer_ = new StreamWriter("LumixBindings.cs");
            writer_.WriteLine("/* ----------------------------------------------------------------------------");
            writer_.WriteLine("* This file was automatically generated by LumixBindings.");
            writer_.WriteLine("* Version " + Bindings.Version);
            writer_.WriteLine(" * ----------------------------------------------------------------------------- */");
            writer_.WriteLine("");
            writer_.WriteLine("");
            //writer_.WriteLine("#ifndef SWIGCSHARP");
            //writer_.WriteLine("#define SWIGCSHARP");
            //writer_.WriteLine("#endif");
        }

        public void FinishCSharp()
        {
            writer_.Flush();
            writer_.Close();
            writer_.Dispose();
        }
        List<string> _writtenFunctions = new List<string>();

        public void WriteLumix(Namespace ns)
        {
            
            foreach (var cl in ns.Values)
            {
                List<string> done = new List<string>();
                writer_.Write("void generate"+cl.Name+"API(){\n");
                foreach(var m in cl.Values)
                {
                   
                    if (!m.Name.StartsWith("get") )
                        continue;
                    var rawName = m.Name.ToLower().Replace("get", "").Replace("set", "");
                    if (rawName.Contains("heightmap"))
                    {

                    }
                    if(done.Contains(rawName))
                        continue;
                    if (m.GetPropertyParts.Length < 3)
                        continue;
                    
                    else if(m.GetPropertyParts.Length > 3)
                    {

                    }
                    
                    writer_.Write("CSHARP_PROPERTY(");
                    writer_.Write(m.ReturnTypemap.TypeSTR + ",");
                    writer_.Write(cl.Name + ",");
                    var split = m.GetPropertyParts;
                    writer_.Write(split[1] + "," + split[2] + ");\n");
                    ///CSHARP_PROPERTY(float, PhysicsScene, Capsule, Radius);
                    done.Add(rawName);
                }
                writer_.Write("}\n");
            }
        }
        public struct PropertyValue
        {
            public string name_;
            public Method getter_;
            public Method setter_;
            public bool HasSetter
            {
                get { return setter_ != null; }
            }

            public bool HasGetter
            {
                get { return getter_ != null; }
            }
        }
        public void GenerateLumixCsharp(Namespace ns)
        {
            writer_.WriteLine("namespace " + "Lumix");
            writer_.WriteLine("{");


            foreach (var en in ns.Enums)
            {
                var cName = en.Name.ToLower();
                if (string.IsNullOrEmpty(cName))
                {
                    Console.WriteLine("Skipped one empty enum :S");
                    continue;
                }
                writer_.Write(en.XMLComment);
                writer_.WriteLine("\t\tpublic enum " + cName.Capitalize());
                writer_.WriteLine("\t\t{");
                int key = 0;
                foreach (var val in en.Values)
                {
                    var valueName = val.Key;
                    int integer = val.Value;
                    if (integer == -1)
                    {
                        writer_.Write("\t\t\t" + valueName);
                    }
                    else
                    {
                        writer_.Write("\t\t\t" + valueName + " = " + integer.ToString());
                    }
                    if (key++ + 1 < en.Values.Count)
                        writer_.WriteLine(",");
                }
                writer_.WriteLine("\n\t\t}");
                writer_.WriteLine();
            }

            foreach (var cl in ns.Values)
            {
                if (writtenClasses.Contains(cl))
                    continue;

                _writtenFunctions.Clear();
                if (cl.Values.Length == 0)
                    continue;
                var hit = writtenClasses.Find(x => x.Name == cl.Name);
                if (hit != null)
                    continue;
                var cName = cl.Name;
                if (cl.Name == "GetTouchPressure")
                {
                    
                }
                writer_.WriteLine(cl.XMLComment);
                writer_.WriteLine("\tpublic " + cl.CSharpClassDecl + " " + cName + ": NativeComponent");//(cl.HasBaseClass ? " : " + cl.BaseClass : ""));
                writer_.WriteLine("\t{");
              //  if (!cl.HasBaseClass)
                writer_.WriteLine("\t\tinternal global::System.IntPtr native_;");
                writer_.WriteLine("\t\tinternal global::System.IntPtr scene_;");
                writer_.WriteLine("\t\tinternal int componentId_;");


                //write down the p/invokes
                foreach (var method in cl.Values)
                {
                    if (_writtenFunctions.Contains(method.Name) || !method.IsPublic || method.Name.Contains("operator"))
                        continue;
                    if (Bindings.IgnoredFunctions.Contains(cl.Name + "_" + method.Name))
                        continue;
                    if (!method.Name.ToLower().StartsWith("set") && !method.Name.ToLower().StartsWith("get"))
                        continue;
                    if (method.IsConstructor)
                        continue;

                    if (method.Name == "GetInt64")
                    {
                        var xml = method.XMLComment;
                    }
                    string ret = ((!method.IsVoid || method.IsConstructor) ? "System.IntPtr" : "void");
                    if (ret != "void")
                    {
                        if (method.ReturnTypemap.IsBasicType)
                            ret = method.ReturnTypemap.FromNative(); //.ReturnValue.Replace("unsigned ","u").Replace("const ","");
                    }
                    string mName = method.Name;
                    string entryPoint = cName + "_" + mName + (method.IsConstructor ? "_Create" : "");

                    string argumentsPI = method.IsConstructor || method.IsStatic ? "" : "global::System.IntPtr scene";
                    //write all arguments
                    for (int i = 0; i < method.Values.Length; i++)
                    {
                        var isP = method.Values[i].TypeMap.IsPointer;
                        if (i == 0 && !method.IsConstructor && !method.IsStatic)
                            argumentsPI += ", ";//self is always upfront
                        var param = method.Values[i];

                        var pt = param.TypeMap.TypeSTR;
                        if (!param.TypeMap.IsBasicType)
                            argumentsPI += "System.IntPtr" + " " + param.Name;
                        else
                            argumentsPI += param.TypeMap.BasicTypeSTR.Replace("unsigned ", "u") + " " + param.Name;
                        if (i + 1 < method.Values.Length)
                            argumentsPI += ", ";

                    }
                    writer_.WriteLine(string.Format(method.CSharpPITemplateLumix,entryPoint, ret, argumentsPI));
                    writer_.WriteLine("");
                    _writtenFunctions.Add(mName);
                }
                _writtenFunctions.Clear();
                string createFunc = "\t\tpublic override void create()\n" +
                                     "\t\t{\n" +
                                    "\t\t\tcomponentId_ = create(entity._universe, entity._entity_id, \""+cl.Name.ToLower()+"\");\n" +
                                    "\t\t\tif (component_id < 0) throw new Exception(\"Failed to create component\");\n" +
                                    "\t\t\t\tscene_ = getScene(entity._universe, \"" + cl.Name.ToLower() + "\");\n" +
                                    "\t\t}\n";
                writer_.Write(createFunc+"\n\n");
                Dictionary<string, PropertyValue> props = new Dictionary<string, PropertyValue>();
                //write down the csharp functions
                foreach (var method in cl.Values)
                {
                    if (_writtenFunctions.Contains(method.Name) || !method.IsPublic || method.Name.Contains("operator"))
                        continue;
                    if (Bindings.IgnoredFunctions.Contains(cl.Name + "_" + method.Name))
                        continue;
                    if (!method.Name.ToLower().StartsWith("set") && !method.Name.ToLower().StartsWith("get"))
                        continue;
                    if (method.IsConstructor)
                        continue;
                    var propName = method.Name.Replace("get", "").Replace("set", "");
                    PropertyValue value;
                    if (!props.ContainsKey(propName)) {
                        value = new PropertyValue();
                    }
                    else
                    {
                        value = props[propName];
                    }
                    value.name_ = propName;
                    if (method.Name.ToLower().StartsWith("get"))
                        value.getter_ = method;
                    else
                        value.setter_ = method;
                    props[propName] = value;
                }
                //write down the properties
                foreach(var p in props.Values)
                {
                    if (!p.HasGetter)
                        continue;
                    writer_.Write("\t\t/// <summary>\n");
                    writer_.Write("\t\t/// Gets " + (p.HasSetter ? "or sets" : "") + " the " + p.name_ + "\n");
                    writer_.Write("\t\t/// </summary>\n");
                    writer_.WriteLine("\t\tpublic " + (p.getter_.ReturnTypemap != null ? p.getter_.ReturnTypemap.ToCsharp() : p.getter_.ReturnValue ) +" " + p.name_);
                    writer_.WriteLine("\t\t{");
                    if (p.HasGetter)
                    {
                        writer_.Write("\t\t\tget { return ");
                        var m = p.getter_;
                        writer_.Write(m.Name + "(scene_, componentId_); }\n");
                    }
                    if (p.HasSetter)
                    {
                        writer_.Write("\t\t\tset { ");
                        var m = p.setter_;
                        writer_.Write(m.Name + "(scene_, componentId_, value); }\n");

                    }
                    writer_.WriteLine("\t\t}\n\n");
                }
                    //write down the csharp functions
                    foreach (var method in cl.Values)
                {
                    continue;
                    if (_writtenFunctions.Contains(method.Name) || !method.IsPublic || method.Name.Contains("operator"))
                        continue;
                    if (Bindings.IgnoredFunctions.Contains(cl.Name + "_" + method.Name))
                        continue;
                    if (!method.Name.ToLower().StartsWith("set") && !method.Name.ToLower().StartsWith("get"))
                        continue;
                    string ret = method.IsConstructor ? "" : (method.ReturnTypemap.ToCsharp());
                    if (!method.IsVoid && ret == "void")
                        ret = method.ReturnTypemap.FromNative();
                    if (method.ReturnTypemap.IsBasicType)
                        ret = method.ReturnTypemap.FromNative();
                    string name = method.Name;
                    if (name == "Variant")
                    {

                    }
                    string funcBody = "";
                    string funcArguments = "";
                    string staticStr = method.IsStatic ? "static" : "";
                    //"\t\tpublic {0} {1}({2})\n\t\t{\t\t\t{3}\n\t\t}"
                    //write all arguments
                    for (int i = 0; i < method.Values.Length; i++)
                    {
                        var param = method.Values[i];

                        var pt = param.TypeMap.TypeSTR;
                        if (!param.TypeMap.IsBasicType)
                        {
                            funcArguments += param.TypeMap.ToCsharp() + " " + param.Name;
                        }
                        else
                            funcArguments += param.TypeMap.BasicTypeSTR.Replace("unsigned ", "u") + " " + param.Name;
                        if (i + 1 < method.Values.Length)
                            funcArguments += ", ";
                    }
                    writer_.WriteLine();
                    //write the function body
                    if (method.IsReturnSomething && !method.IsConstructor)
                    {
                        funcBody += "\n\t\t\treturn ";
                        if (Bindings.Classes.Contains(method.ReturnTypemap.ToCsharp()))
                            funcBody += "new " + method.ReturnTypemap.ToCsharp() + "(";
                        funcBody += cl.Name + "_" + name + ("(");
                        if (!method.IsConstructor && !method.IsStatic)
                        {
                            funcBody += "native_";
                        }
                        for (int i = 0; i < method.Values.Length; i++)
                        {
                            if (i == 0 && !method.IsConstructor && !method.IsStatic)
                                funcBody += ", ";//self is always upfront
                            var param = method.Values[i];
                            funcBody += param.Name;
                            if (Bindings.Classes.Contains(param.TypeMap.ToCsharp()))
                                funcBody += ".native_.Handle";
                            if (i + 1 < method.Values.Length)
                                funcBody += ", ";
                        }
                        funcBody += ")";
                        if (Bindings.Classes.Contains(method.ReturnTypemap.ToCsharp()))
                            funcBody += ");";
                        else
                            funcBody += ";";

                    }
                    else if (method.IsConstructor)
                    {
                        if (!cl.HasBaseClass)
                            funcBody += "\n\t\t\t";
                        if (method.Values.Count() == 0)
                            funcBody += "native_ = new System.Runtime.InteropServices.HandleRef(this, ";
                        funcBody += cl.Name + "_" + name + ("_Create(");
                        for (int i = 0; i < method.Values.Length; i++)
                        {
                            //if (i == 0 && !method.IsConstructor && !method.IsStatic)
                            //    funcBody += ", ";//self is always upfront
                            var param = method.Values[i];
                            funcBody += param.Name;
                            if (Bindings.Classes.Contains(param.TypeMap.ToCsharp()))
                                funcBody += ".native_.Handle";
                            if (i + 1 < method.Values.Length)
                                funcBody += ", ";
                        }
                        funcBody += ")";
                        if (method.Values.Count() == 0)
                            funcBody += ")";
                        if (!cl.HasBaseClass)
                            funcBody += ";";
                    }
                    else//normal void method
                    {
                        funcBody += "\n\t\t\t";
                        funcBody += cl.Name + "_" + name + ("(");
                        if (!method.IsConstructor && !method.IsStatic)
                        {
                            funcBody += "native_";
                        }
                        for (int i = 0; i < method.Values.Length; i++)
                        {
                            if (i == 0 && !method.IsConstructor && !method.IsStatic)
                                funcBody += ", ";//self is always upfront
                            var param = method.Values[i];
                            funcBody += param.Name;
                            if (Bindings.Classes.Contains(param.TypeMap.ToCsharp()))
                                funcBody += ".native_.Handle";
                            if (i + 1 < method.Values.Length)
                                funcBody += ", ";
                        }
                        funcBody += ");";
                    }
                    string function = "";
                    if (!cl.HasBaseClass || !method.IsConstructor)
                        function = string.Format(method.CSharpFuncDecl, ret, name, funcArguments, funcBody, method.XMLComment, staticStr);
                    else
                        function = string.Format(method.CSharpFuncDeclBase, ret, name, funcArguments, funcBody, method.XMLComment);
                    writer_.WriteLine(function);
                    if (method.IsConstructor)//write internal constructor
                    {
                        string nativeCtorName = cl.Name + "_" + method.Name + "_Create";
                        writer_.WriteLine("");
                        if (!cl.HasBaseClass)
                        {
                            writer_.WriteLine("\t\tinternal " + cl.Name + "(System.IntPtr native)");
                            writer_.WriteLine("\t\t{");
                            writer_.WriteLine("\t\t\tnative_ = new System.Runtime.InteropServices.HandleRef(this, native);");
                            writer_.WriteLine("\t\t}");
                        }
                        else
                        {
                            writer_.WriteLine("\t\tinternal " + cl.Name + "(System.IntPtr native)");
                            writer_.WriteLine("\t\t\t:base(native)");
                            writer_.WriteLine("\t\t{");
                            //writer_.WriteLine("\t\t\tnative_ = new System.Runtime.InteropServices.HandleRef(this, native);");
                            writer_.WriteLine("\t\t}");
                        }
                    }
                    writer_.WriteLine("");
                    _writtenFunctions.Add(method.Name);
                }
                writer_.WriteLine("\t}//end class" + cName);
                writtenClasses.Add(cl);
            }
            writer_.WriteLine("}//end namespace" + ns.Name);
        }
        public void GenerateCSharp(Namespace ns)
        {
            writer_.WriteLine("namespace " + ns.Name);
            writer_.WriteLine("{");


            foreach (var en in ns.Enums)
            {
                var cName = en.Name.ToLower();
                if (string.IsNullOrEmpty(cName))
                {
                    Console.WriteLine("Skipped one empty enum :S");
                    continue;
                }
                writer_.Write(en.XMLComment);
                writer_.WriteLine("\t\tpublic enum " + cName.Capitalize());
                writer_.WriteLine("\t\t{");
                int key = 0;
                foreach (var val in en.Values)
                {
                    var valueName = val.Key;
                    int integer = val.Value;
                    if (integer == -1)
                    {
                        writer_.Write("\t\t\t" + valueName);
                    }
                    else
                    {
                        writer_.Write("\t\t\t" + valueName + " = " + integer.ToString());
                    }
                    if (key++ + 1 < en.Values.Count)
                        writer_.WriteLine(",");
                }
                writer_.WriteLine("\n\t\t}");
                writer_.WriteLine();
            }

            foreach (var cl in ns.Values)
            {
                if (writtenClasses.Contains(cl))
                    continue;

                _writtenFunctions.Clear();
                if (cl.Values.Length == 0)
                    continue;
                var hit = writtenClasses.Find(x => x.Name == cl.Name);
                if (hit != null)
                    continue;
                var cName = cl.Name;
                if(cl.Name == "GetTouchPressure")
                {

                }
                writer_.WriteLine(cl.XMLComment);
                writer_.WriteLine("\tpublic " + cl.CSharpClassDecl +" " +  cName +(cl.HasBaseClass ? " : " + cl.BaseClass : ""));
                writer_.WriteLine("\t{");
                if (!cl.HasBaseClass)
                    writer_.WriteLine("\t\tinternal global::System.Runtime.InteropServices.HandleRef native_;");
                //write down the p/invokes
                foreach (var method in cl.Values)
                {
                    if (_writtenFunctions.Contains(method.Name) || !method.IsPublic || method.Name.Contains("operator"))
                        continue;
                    if (Bindings.IgnoredFunctions.Contains(cl.Name + "_" + method.Name))
                        continue;
                    if (method.Name == "GetInt64")
                    {
                        var xml = method.XMLComment;
                    }
                    string ret = ((!method.IsVoid || method.IsConstructor) ? "System.IntPtr" : "void");
                    if(ret != "void")
                    {
                        if (method.ReturnTypemap.IsBasicType)
                            ret = method.ReturnTypemap.FromNative(); //.ReturnValue.Replace("unsigned ","u").Replace("const ","");
                    }
                    string mName = method.Name;
                    string entryPoint = cName + "_" + mName + (method.IsConstructor ? "_Create" : "");

                    string argumentsPI =  method.IsConstructor || method.IsStatic?  "" : "global::System.Runtime.InteropServices.HandleRef self";
                    //write all arguments
                    for (int i = 0; i < method.Values.Length; i++)
                    {
                        var isP = method.Values[i].TypeMap.IsPointer;
                        if (i == 0 && !method.IsConstructor && !method.IsStatic)
                            argumentsPI += ", ";//self is always upfront
                        var param = method.Values[i];

                        var pt = param.TypeMap.TypeSTR;
                        if (!param.TypeMap.IsBasicType)
                            argumentsPI += "System.IntPtr" + " " + param.Name;
                        else
                            argumentsPI += param.TypeMap.BasicTypeSTR.Replace("unsigned ","u") + " " + param.Name;
                        if (i + 1 < method.Values.Length)
                            argumentsPI += ", ";
                       
                    }
                    writer_.WriteLine(string.Format(method.CSharpPITemplate, Bindings.NativeLib, entryPoint, ret, argumentsPI));
                    writer_.WriteLine("");
                    _writtenFunctions.Add(mName);
                }
                _writtenFunctions.Clear();

                              
                //write down the csharp functions
                foreach(var method in cl.Values)
                {
                    if (_writtenFunctions.Contains(method.Name) || !method.IsPublic || method.Name.Contains("operator"))
                        continue;
                    if (Bindings.IgnoredFunctions.Contains(cl.Name + "_" + method.Name))
                        continue;
                    string ret = method.IsConstructor ? "" : (method.ReturnTypemap.ToCsharp());
                    if (!method.IsVoid && ret == "void")
                        ret = method.ReturnTypemap.FromNative();
                    if (method.ReturnTypemap.IsBasicType)
                        ret = method.ReturnTypemap.FromNative();
                    string name = method.Name;
                    if(name == "Variant")
                    {

                    }
                    string funcBody = "";
                    string funcArguments = "";
                    string staticStr = method.IsStatic ? "static" : "";
                    //"\t\tpublic {0} {1}({2})\n\t\t{\t\t\t{3}\n\t\t}"
                    //write all arguments
                    for (int i = 0; i < method.Values.Length; i++)
                    {
                        var param = method.Values[i];

                        var pt = param.TypeMap.TypeSTR;
                        if (!param.TypeMap.IsBasicType)
                        {
                            funcArguments += param.TypeMap.ToCsharp() + " " + param.Name;
                        }
                        else
                            funcArguments += param.TypeMap.BasicTypeSTR.Replace("unsigned ","u") + " " + param.Name;
                        if (i + 1 < method.Values.Length)
                            funcArguments += ", ";
                    }
                    writer_.WriteLine();
                    //write the function body
                    if (method.IsReturnSomething && !method.IsConstructor)
                    {
                        funcBody += "\n\t\t\treturn ";
                        if (Bindings.Classes.Contains(method.ReturnTypemap.ToCsharp()))
                            funcBody += "new " + method.ReturnTypemap.ToCsharp() + "(";
                        funcBody += cl.Name + "_" + name + ("(");
                        if (!method.IsConstructor && !method.IsStatic)
                        {
                            funcBody += "native_";
                        }
                        for (int i = 0; i < method.Values.Length; i++)
                        {
                            if (i == 0 && !method.IsConstructor && !method.IsStatic)
                                funcBody += ", ";//self is always upfront
                            var param = method.Values[i];
                            funcBody += param.Name;
                            if (Bindings.Classes.Contains(param.TypeMap.ToCsharp()))
                                funcBody += ".native_.Handle";
                            if (i + 1 < method.Values.Length)
                                funcBody += ", ";
                        }
                        funcBody += ")";
                        if (Bindings.Classes.Contains(method.ReturnTypemap.ToCsharp()) )
                            funcBody += ");";
                        else 
                            funcBody += ";";
                                
                    }
                    else if(method.IsConstructor)
                    {
                        if (!cl.HasBaseClass)
                            funcBody += "\n\t\t\t";
                        if (method.Values.Count() == 0)
                            funcBody += "native_ = new System.Runtime.InteropServices.HandleRef(this, ";
                        funcBody += cl.Name + "_" + name + ("_Create(");
                        for (int i = 0; i < method.Values.Length; i++)
                        {
                            //if (i == 0 && !method.IsConstructor && !method.IsStatic)
                            //    funcBody += ", ";//self is always upfront
                            var param = method.Values[i];
                            funcBody += param.Name;
                            if (Bindings.Classes.Contains(param.TypeMap.ToCsharp()))
                                funcBody += ".native_.Handle";
                            if (i + 1 < method.Values.Length)
                                funcBody += ", ";
                        }
                        funcBody += ")";
                        if (method.Values.Count() == 0)
                            funcBody += ")";
                            if (!cl.HasBaseClass)
                            funcBody += ";";
                    }
                    else//normal void method
                    {
                        funcBody += "\n\t\t\t";
                        funcBody += cl.Name + "_" + name + ("(");
                        if (!method.IsConstructor && !method.IsStatic)
                        {
                            funcBody += "native_";
                        }
                        for (int i = 0; i < method.Values.Length; i++)
                        {
                            if (i == 0 && !method.IsConstructor && !method.IsStatic)
                                funcBody += ", ";//self is always upfront
                            var param = method.Values[i];
                            funcBody += param.Name;
                            if (Bindings.Classes.Contains(param.TypeMap.ToCsharp()))
                                funcBody += ".native_.Handle";
                            if (i + 1 < method.Values.Length)
                                funcBody += ", ";
                        }
                        funcBody += ");";
                    }
                    string function = "";
                    if (!cl.HasBaseClass ||!method.IsConstructor)
                        function = string.Format(method.CSharpFuncDecl, ret, name, funcArguments, funcBody, method.XMLComment,staticStr);
                    else
                        function = string.Format(method.CSharpFuncDeclBase, ret, name, funcArguments, funcBody, method.XMLComment);
                    writer_.WriteLine(function);
                    if(method.IsConstructor)//write internal constructor
                    {
                        string nativeCtorName = cl.Name + "_" + method.Name + "_Create";
                        writer_.WriteLine("");
                        if (!cl.HasBaseClass)
                        {
                            writer_.WriteLine("\t\tinternal " + cl.Name + "(System.IntPtr native)");
                            writer_.WriteLine("\t\t{");
                            writer_.WriteLine("\t\t\tnative_ = new System.Runtime.InteropServices.HandleRef(this, native);");
                            writer_.WriteLine("\t\t}");
                        }
                        else
                        {
                            writer_.WriteLine("\t\tinternal " + cl.Name + "(System.IntPtr native)");
                            writer_.WriteLine("\t\t\t:base(native)");
                            writer_.WriteLine("\t\t{");
                            //writer_.WriteLine("\t\t\tnative_ = new System.Runtime.InteropServices.HandleRef(this, native);");
                            writer_.WriteLine("\t\t}");
                        }
                    }
                    writer_.WriteLine("");
                    _writtenFunctions.Add(method.Name);
                }
                writer_.WriteLine("\t}//end class" + cName);
                writtenClasses.Add(cl);
            }
            writer_.WriteLine("}//end namespace" + ns.Name);
        }
        public void Save(Namespace ns)
        {

            foreach (var cl in ns.Values)
            {
                _writtenFunctions.Clear();
                if (cl.Values.Length == 0)
                    continue;
                var hit = writtenClasses.Find(x => x.Name == cl.Name); //.Select(x => x.Name == cl.Name);
                if (hit != null)
                    continue;

                var name = cl.Name;
                foreach (var method in cl.Values)
                {
                    
                    if (_writtenFunctions.Contains(method.Name))
                        continue;
                    if (method.IsAbstract || (method.IsConstructor && cl.IsAbstract) || !method.IsPublic || method.IsTemplate)
                        continue;

                    var mName = method.Name;
                    if (Bindings.IgnoredFunctions.Contains(cl.Name + "_" + mName) || mName.Contains("operator"))
                        continue;
                    if(mName == "GetInt64")
                    {

                    }
                    writer_.Write("ATOMIC_BINDING_EXPORT " + (method.IsVoid ? (method.IsConstructor && !cl.IsAbstract ? "void*" :"void") : method.ReturnTypemap.NativeC) + " ATOMIC_BINDING_STDCALL " + name + "_" + mName + (method.IsConstructor ? "_Create" : "") + "( " + (method.IsConstructor || method.IsStatic ? "" : "void* self"));// + " ) {");

                    //write all arguments
                    for(int i =0; i < method.Values.Length;i++)
                    {
                        var isP = method.Values[i].TypeMap.IsPointer;
                        if (i == 0 && !method.IsConstructor && !method.IsStatic)
                            writer_.Write(", ");//self is always upfront
                        var param = method.Values[i];

                        var pt = param.TypeMap.TypeSTR;
                        if (!param.TypeMap.IsBasicType)
                            writer_.Write((param.TypeMap.IsEnum ? "int" : "void *") + " " + param.Name);
                        else
                            writer_.Write(param.TypeMap.BasicTypeSTR + " " + param.Name);
                        if (i + 1 < method.Values.Length)
                            writer_.Write(", ");
                    }
                    //close arguments
                    writer_.WriteLine(" ) {");
                    //cast to our actual object, if it's not a constructor
                    if (!method.IsConstructor && !method.IsStatic)
                        writer_.WriteLine("\t" + cl.FullyQualifiedName + " *ptr = (" + cl.FullyQualifiedName + " *)self;");
                    else if(!method.IsStatic) //that's a constructor, construct it !
                    {
                        writer_.WriteLine("\t" + cl.FullyQualifiedName + " *ptr;");
                    }
                    //cast all arguments
                    for(int i =0; i < method.Values.Length;i++)
                    {
                        var param = method.Values[i];
                        if (param.TypeMap.IsPointer || param.TypeMap.IsAbstract || param.TypeMap.IsReference)
                        {
                            if (param.TypeMap.IsVector)
                            {
                                writer_.WriteLine("\t" + param.TypeMap.VectorDecl +"<" + param.TypeMap.VectorTypeFQ + ">" + " * arg" + i + " = (" + param.TypeMap.VectorDecl + "<" + param.TypeMap.VectorTypeFQ + ">" +" *)" + param.Name + ";");
                            }
                            else
                            {
                                writer_.WriteLine("\t" + param.FullyQualyfiedType + " * arg" + i + " = (" + param.FullyQualyfiedType + " *)" + param.Name + ";");
                            }
                        }
                        else if (param.TypeMap.IsConst && !param.TypeMap.IsBasicType)
                            writer_.WriteLine("\t" + param.FullyQualyfiedType + " * arg" + i + " = &(" + param.FullyQualyfiedType + " *)" + param.Name + ";");
                        else if (param.TypeMap.IsBasicType)
                            writer_.WriteLine("\t" + param.TypeMap.BasicTypeSTR + " arg" + i + " = " + param.Name + ";");
                        else if (param.TypeMap.IsEnum)
                            writer_.WriteLine("\t int arg" + i + " = " + param.Name + ";");
                        else
                            writer_.WriteLine("\t" + param.FullyQualyfiedType + " arg" + i + " = *(" + param.FullyQualyfiedType + " *)" + param.Name + ";");
                    }
                    //check wether we should return somthing or not
                    bool isRetPtr = method.ReturnValue.Contains("*") || (method.ReturnTypemap != null && method.ReturnTypemap.IsPointer);
                    var stm = method.ReturnValue == "void" ? "" : "return ";
                    if(stm == "return ")
                    {
                        var isVector = method.ReturnTypemap.IsVector;
                        if (method.ReturnTypemap.VectorIsConstRef)
                        {
                            if (method.ReturnTypemap.NativeCPP.Contains("Atomic::"))
                                stm += "(void*)(" + method.ReturnTypemap.NativeCPP + ")";
                            else
                            {
                                var wNS = method.ReturnTypemap.VectorDecl.Replace("Atomic::", "");
                                var cNCPP = method.ReturnTypemap.NativeCPP.Replace(wNS, method.ReturnTypemap.VectorDecl);
                                stm += "(" + cNCPP + ")";
                            }
                        }
                        if(method.ReturnTypemap.IsVector)
                        {
                            stm = stm.Replace("&", "*");
                            stm += (method.ReturnTypemap.NeedCCast ? "( " + method.ReturnTypemap.NativeC + ")" : "");
                            if (!method.ReturnTypemap.IsPointer)
                                stm += "&";
                        }
                        else
                        {
                            stm += (method.ReturnTypemap.NeedCCast ? "( " + method.ReturnTypemap.NativeC + ")" : "");
                            stm += ((method.ReturnTypemap.IsConst && !method.ReturnTypemap.IsConstPointer && !method.ReturnTypemap.IsBasicType) || (!isRetPtr) ? "&" : "");
                        }
                   
                        if (method.ReturnTypemap.IsEnum || ns.Enums.Find(x => x.Name == method.ReturnTypemap.TypeSTR.Replace("Atomic::","")) != null ||method.ReturnTypemap.IsBasicType)
                            stm = stm.Replace("&", "");
                        var str = method.ReturnTypemap.TypeSTR;
                        if (method.ReturnTypemap.IsBasicType)
                            stm = stm.Replace("&", "");
                    }
                    writer_.Write("\t" + stm);
                    if(method.IsConstructor)
                    {
                        //create the pointer!
                        writer_.Write(string.Format("ptr = new {0}", cl.FullyQualifiedName));
                        if(method.HasParameter)
                        {
                            writer_.Write("( ");
                            for (int i = 0; i < method.Values.Length; i++)
                            {
                                var param = method.Values[i];
                                writer_.Write("arg" + i);
                                if (i + 1 < method.Values.Length)
                                    writer_.Write(", ");
                                else
                                    writer_.WriteLine(" );");
                            }
                        }
                        else
                        {
                            writer_.WriteLine("();");
                        }
                        writer_.WriteLine("\treturn (void*)ptr;");
                    }
                    //call the function
                    else if (method.HasParameter)
                    {
                        if (!method.IsStatic)
                            writer_.Write(string.Format("(({0} *)ptr)->{1}( ", cl.FullyQualifiedName, mName));
                        else
                        {
                            writer_.Write(string.Format(cl.FullyQualifiedName + "::{1}( ", cl.FullyQualifiedName, mName));
                        }
                        for (int i = 0; i < method.Values.Length; i++)
                        {
                            var param = method.Values[i];
                            if (cl.Name == "Node" && method.Name == "SetTags")//custom cast hack...
                                writer_.Write("(Atomic::StringVector const &)");
                            if (param.TypeMap.VectorIsConstRef)
                                writer_.Write("(" + param.TypeMap.NativeCPP + ")");
                            if (param.TypeMap.IsAbstract && !param.TypeMap.IsPointer || param.TypeMap.IsReference)
                                writer_.Write("*");
                            if (param.TypeMap.IsEnum) //cast int to enum
                            {
                                writer_.Write("(" + param.FullyQualyfiedType + ")");
                            }
                            //else if (param.TypeMap.IsReference)
                            //    writer_.Write("*");
                            writer_.Write("arg" + i);
                            if (i + 1 < method.Values.Length)
                                writer_.Write(", ");
                            else
                                writer_.WriteLine(" );");
                        }
                    }
                    else
                    {
                        if (!method.IsStatic)
                            writer_.WriteLine(string.Format("(({0} *)ptr)->{1}(); ", cl.FullyQualifiedName, mName));
                        else
                            writer_.WriteLine(string.Format(cl.FullyQualifiedName + "::{1}();", cl.FullyQualifiedName, mName));
                    }
                    writer_.WriteLine("}");
                    writer_.WriteLine("");
                    writer_.WriteLine("");
                    writer_.Flush();

                    _writtenFunctions.Add(method.Name);
                }
                writtenClasses.Add(cl);
            }
        }
    }
}
